\section{Кратчайшие пути}

Пусть имеем взвешенный граф (все веса положительные!). Есть некоторая вершина, от которой мы хотим найти кратчайшие пути до всех остальных вершин с минимальным суммарным весом.

В начальной вершине мы точно знаем ответ --- $0$. Мы смотрим все соседние стартовой вершины и говорим, что туда мы точно можем добраться за вес соединяющего их ребра (изначально во всех вершинах стоит $+\infty$). Теперь выбираем вершину с наименьшим посчитанным на~этом этапе путём. Утверждается, что этот путь для неё действительно наименьший (не может уменьшиться при дальнейшем исполнении алгоритма). И из этой вершины обновляем все ответы, которые она может улучшить. Можно также сохранять ребро, которое последний раз обновило путь к~данной вершине (для построения дерева кратчайших путей).

Выбирать кратчайшую вершину можно полным перебором вершин. Тогда асимптотика составляет $O(n^2 + m)$. Эта версия алгоритма выгодна, если $m \sim n^2$ (много рёбер и много обновлений весов).

Можно пользоваться структурой данных по типу множества или приоритетной очереди для выбора ребра с минимальным весом и обновления весов (вот из-за этого работает медленно, если много рёбер). Тогда асимптотика составит $O(n\log n + m\log n)$.

\subsubsection{Реализация}

Реализация без очереди:

\begin{minted}[linenos, mathescape]{cpp}
// Список смежности графа (храним также вес ребра в вершину)
vector<vector<pair<int, int>>> adj;
vector<int> dist(n, INF), marks(n, 0);

dist[start] = 0;
for (int i = 0; i < n; ++i)
{
    int mi = INF, mi_v = -1;
    for (int j = 0; j < n; ++j)
    {
        if (!marks[j] && dist[j] < mi)
            mi = dist[j], mi_v = j;
        marks[mi_v] = 1;
        for (auto u : adj[mi_v])
        {
            if (dist[u.first] > dist[mi_v] + u.second)
                dist[u.first] = dist[mi_V] + u.second;
        }
    }
}

\end{minted}

Реализация с очередью:

\begin{minted}[linenos, mathescape]{cpp}
vector<vector<pair<int, int>>> adj;
vector<int> dist(n, INF), marks(n, 0);

dist[start] = 0;

priority_queue<pair<int, int>> q;
for (int i = 0; i < n; ++i)
    // очередь с приоритетом в начале хранит максимум,
    // а нам нужен минимум, поэтому храним дистанцию
    // со знаком $\text{<<минус>>}$
    q.emplace(-dist[i], i);

while (!q.empty())
{
    int v;
    v = q.top().second;
    q.pop();
    if (!marks[v])
    {
        marks[v] = 1;
        for (auto u : adj[v])
        {
            if (dist[u.first] > dist[v] + u.second)
            {
                dist[u.first] = dist[v] + u.second;
                q.emplace(-dist[u.first], u.first);
            }
        }
    }
}
\end{minted}

\subsection{Алгоритм Форда "--- Беллмана}

Алгоритм позволяет находить кратчайшие пути в графах с отрицательными весами рёбер. Заметим, что мы работаем без отрицательных циклов (циклов с отрицательной суммой входящих в него рёбер). Ведь тогда можно бесконечно ходить по нему и уменьшать расстояние.

\begin{lemma} Если существует ребро $y \rightarrow x$ с весом $W(y, x)$, то выполняется
    \textnormal{\texttt{dist[$x$] $\leqslant$ dist[$y$] + $W(y, x)$}}
\end{lemma}

\begin{lemma}
    Если в пути есть цикл, то можем его отбросить (т.\,к. он только увеличивает суммарный вес).
\end{lemma}

Изначально в стартовой вершине вес $0$, в остальных $+\infty$. Будем ходить по всем вершинам и обновлять расстояние по \textbf{лемме 1}. Утверждается, что после $i$-го обхода все кратчайшие пути длины $i$ будут определены. Тогда нам нужно совершить $n-1$ обход и мы получим все кратчайшие пути.

\subsubsection{Реализация}

\begin{minted}[linenos, mathescape]{cpp}
// Список смежности графа (храним также вес ребра в вершину)
vector<vector<pair<int, int>>> adj;
vector<int> dist(n, INF);

dist[start] = 0;

for (int i = 0; i < n - 1; ++i)
{
    for (int v = 0; v < n; ++v)
    {
        for (auto u : adj[v])
            if(dist[u.first] > dist[v] + u.second)
                dist[u.first] = dist[v] + u.second;
    }
}
\end{minted}

Может показаться, что асимптотика алгоритма больше $n^2$, но на самом деле весь внутренний цикл (идём по \texttt{v}) --- это $O(m)$. Таким образом, общая асимптотика $O(n\cdot m)$.

Оптимизированная версия алгоритма Форда "--- Беллмана:

\begin{minted}[linenos, mathescape]{cpp}
// Список смежности графа (храним также вес ребра в вершину)
vector<vector<pair<int, int>>> adj;
vector<int> dist(n, INF);
bool any = 1;
int cnt = 0;

dist[start] = 0;

while (any && cnt < n)
{
    any = 0, cnt++;
    for (int v = 0; v < n; ++v)
    {
        for (auto u : adj[v])
            if (dist[u.first] > dist[v] + u.second)
            {
                dist[u.first] = dist[v] + u.second;
                any = 1;
            }
    }
}
\end{minted}

Теперь если мы ничего не обновили на каком-то этапе, то мы сразу выходим. Если мы что-то изменили на последней итерации, то у нас есть отрицательный цикл.

\subsection{Алгоритм Флойда "--- Уоршелла}

Здесь находим двумерный массив \texttt{dist[$i$][$j$]} размера $n \times n$, хранящий все расстояния между вершинами.

\begin{lemma}[Дискретное неравенство треугольника в метрике ориентированных взвешенных графов]
    \textnormal{\texttt{dist[$i$][$j$] $\leqslant$ dist[$i$][$k$] + dist[$k$][$j$]}}.
\end{lemma}

\begin{lemma}[Первое свойство меры]
    \textnormal{\texttt{dist[$i$][$i$] = 0}}.
\end{lemma}

\begin{lemma}
    \textnormal{\texttt{dist[$u$][$v$] $\leqslant W(u, v)$}}.
\end{lemma}

\subsubsection{Реализация}

\begin{minted}[linenos, mathescape]{cpp}
// Список смежности графа (храним также вес ребра в вершину)
vector<vector<int>> dist(n, vector<int>(n, INF));

for (int i = 0; i < m; ++i)
{
    cin >> u >> v >> w;
    // Выбираем наименьшее кратное ребро
    if (dits[u][v] > w)
        dist[u][v] = w;
}

for (int i = 0; i < n; ++i)
    dist[i][i] = 0;

for (int k = 0; k < n; ++k)
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            if (dist[i][j] > dist[i][k] + dist[k][j])
                dist[i][j] = dist[i][k] + dist[k][j];
\end{minted}

Приведём 2 схемы доказательства корректности алгоритма:

\begin{enumerate}
    \item \textbf{Индукция: } после $k$-го прохода имеем <<настоящие>> кратчайшие пути длины $k+1$, содержащие как промежуточные все вершины $0,\, 1,\,\ldots,\,k$. Таким образом через $n$ проходов мы получим все кратчайшие пути.
    \item \textbf{От противного:} пусть есть ненайденные пути. Из них возьмём кратчайший (по количеству входящих в него рёбер) $i\rightarrow j$, а на~нём возьмём вершину с максимальным номером $m$ ($m > \min\{i, j\}$, так как иначе этот путь точно найден). Тогда не найден один из~путей $i\rightarrow m$ или $m\rightarrow j$. Причём, оба этих пути короче $i\rightarrow j$. Противоречие, так как брали $i\rightarrow j$
\end{enumerate}

Асимптотика составляет $O(n^3)$, но это куб с маленькой константой, ведь мы не используем почти никаких дополнительных структур данных (мы даже сам граф не храним, мы храним только матрицу \texttt{dist}). 


\section{Корневые оптимизации}

Иногда в задаче возникают ситуации, когда мы умеем решать её, когда для какой-то величины выполнено свойство, что она всегда либо меньше, либо больше, чем $\sqrt{n}$. Данный подход и называется корневой оптимизацией.

Примерами применения данной идеи могут служить: алгоритм проверки числа на простоту за $O(\sqrt{n})$ или факт, что если сумма неотрицательных чисел равна $n$, то различных среди них не более $\sqrt{n}$. Также можно вспомнить идею, что если $a \cdot b \leqslant n$, то одно из чисел $a$ или $b$ должно не превышать $\sqrt{n}$.

\subsection{Корневая декомпозиция на массиве}

\begin{problem}
    Дан массив $\{a_0, a_1, \ldots, a_n\}$. Нужно обрабатывать на нём два типа запросов:
    \begin{enumerate}[nolistsep]
        \item Найти сумму на отрезке $[a_l\ldots a_r]$;
        \item Увеличить значение $i$-го элемента на $x$.
    \end{enumerate}
\end{problem}

Разобьём массив на блоки размера $s = \lceil\sqrt{n}\rceil$ и в каждом блоке $i$ предпосчитаем сумму $b_i$ элементов в нём. Массив разбивается на блоки примерно так:
\[
    \underbrace{a_0, a_1, \ldots, a_{s - 1}}_{b_0},\ \underbrace{a_s, a_{s + 1}, \ldots, a_{2 \cdot s - 1}}_{b_1},\ \ldots,\ \underbrace{a_{(s - 1) \cdot s}, a_{(s - 1) \cdot s + 1}, \ldots, a_{n - 1}}_{b_{s - 1}}.
\]

Последний блок может содержать меньше, чем $s$, элеметов (если $n$ не является полным квадратом), --- это не существенно. Итак, на каждом блоке $i$ мы знаем сумма на нём
\[
    b_i = \ds\sum_{j = s \cdot i}^{\min\{n - 1, (i + 1) \cdot s - 1\}}a_i.
\]

Этот предпосчёт занял у нас $O(n)$ времени. Теперь чтобы посчитать сумму на отрезке $[a_l\ldots a_r]$, нужно посчитать за $O(\sqrt{n})$ суммы на перфиксе и суффиксе до ближайшего блока, а потом прибавить сумму чисел в этом блоке.

\begin{minted}[linenos, mathescape]{cpp}
int n, m; // $n$ - длина массива, $m$ - число запросов
cin >> n >> m;
vector<int> a(n);
for (int i = 0; i < n; ++i)
    cin >> a[i];

// Предпосчёт
int s = (int)sqrt((ld)n) + 1;
vector<int> b(s, 0);
for (int i = 0; i < n; ++i)
    b[i / s] += a[i];

while (m--)
{
    int l, r;
    cin >> l >> r;
    int summ = 0;
    for (int i = l; i <= r; )
    {
        if (!(i % s) && i + s - 1 <= r)
        {
            summ += b[i / s];
            i += s;
        }
        else
        {
            summ += a[i];
            ++i;
        }
    }
}
\end{minted}

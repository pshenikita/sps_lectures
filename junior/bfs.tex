\section{Введение в графы. Обход в ширину}

Будем рассматривать граф $G$ с множеством вершин $V \vcentcolon = \{0, 1, \ldots, n \hm - 1\}$ и множеством рёбер $E$. 

\subsection{Способы хранения графов}

Есть несколько способов хранения графов, каждый из которых удобен в разных ситуациях.

\begin{enumerate}
    \item \textbf{Список рёбер}. Название говорит само за себя: заводится массив, в котором хранятся пары инцидентных вершин. Применяется, например, в алгоритме Краскала (см.\,лекцию по СНМ).
    \item \textbf{Матрица смежности}. Заведём двумерный массив $a$ размера $n \times n$, заполненный следующим образом:
    \[
    a_{ij} =
    \begin{cases}
        1,&\text{если $(i, j) \in E$},\\
        0,&\text{иначе}.
    \end{cases}
    \]
    Отметим, что для неориентированного графа матрица смежности является симметрической.
    \item \textbf{Список смежности}. Заведём двумерный массив $a$ длины $n$, в котором по индексу $i$ хранится массив вершин, инцидентных $i$. Этот способ обычно удобнее всего, т.\,к. так проще всего хранить список соседних вершин.
\end{enumerate}

\subsection{Идея поиска в ширину}

При обходе в ширину мы идём по вершинам в порядке, в котором они бы сгорали, если поджечь начальную (каждую секунду огонь распространяется на соседние вершины). Моделируем данный процесс, пока не сгорит весь граф. Важно помнить, что мы не поджигаем уже горящие вершины. Т.\,к. огонь распространяется равномерно по кратчайшим путям, секунда, на которой сгорела $i$-я вершина --- это и есть расстояние до неё. Часто в задачах граф бывает задан неявно (например, в виде шахматной доски).

\subsection{Реализация}

\begin{minted}[linenos, mathescape]{cpp}
// Список смежности графа $G$ размера $n$
vector<vector<int>> adj;
// Векторы для хранения расстояний до каждой вершины и её предков
vector<int> dist, parent;

void bfs(int start)
{
    queue<int> q; // Очередь для хранения горящих вершин
    dist.assign(n, INF);
    parent.assign(n, -1);
    q.push(start);
    dist[start] = 0;
    while (!q.empty())
    {
        int v = q.front();
        q.pop();
        for (auto u : adj[v])
        {
            if (dist[u] == INF)
            {
                dist[u] = dist[v] + 1;
                parent[u] = v;
                q.push(u);
            }
        }
    }
}
\end{minted}

